Question 1: Regular Expression Warmup [15 points]
-------------------------------------------------

i) Suppose you have a regular expression that contain n characters
   concatinated (see following table).
   
      n     |   RegExp
      ------|---------------
         1  |  "c"
         2  |  "cc"
         3  |  "ccc"
         4  |  "ccc"
         .  |
         .  |
         .  |

   This would generate a DFA with n+1 states. In this DFA, there would be a
   state for every character and an accept state for the last character. To
   eliminate the +1 in n+1, one can modify the regular expression so that last
   character is optional. For example, "ccc*" (see table).

      n     |   RegExp  | number of states in DFA
      ------|-----------|------------------------
         1  |  "c*"     |  1
         2  |  "cc*"    |  2
         3  |  "ccc*"   |  3
         4  |  "ccc*"   |  4
         .  |           |  .
         .  |           |  .
         .  |           |  .

   Now there are n-1 states for each character and because last character is
   preceded with a "*", you have a transition from start state to accept state
   eliminating the need for an extra state.

ii) (c|%)(c|%)*

iii) (c|c|c|c)*

iv) (c)*, (c*)*, ((c*)*)*, ...

v) 


Question 2: A Science Experiment  [10 points]
---------------------------------------------

- The potential perforamnce problem with the given jflex program is that it
  starts at the top of the file and tries to match the given pattern
  "(.|\n)*ABORT\n". This can be expensive if the file is large and contain many
  failures which are marked as "ABORT".

- Assuming nothing (other than data) is written to the file when a sucessful
  run is completed, more eficent program would start looking at the file from
  the bottom and continue up untill it sees a "ABORT" flag. Now everything below
  this flag can be presented and aeverything above ignored.

- The following is a jflex program that solves this problem:


Question 3: Syntax Uncoloring  [15 points]
------------------------------------------

- The following jflex program convert html generated by MiniColor into plain
  text that contain the original mini program.

   // Given a HTML file that is generated from MiniColor,
   // this program remove all the HTML tags leaving only the 
   // original mini program
   //
   //    $ jflex Uncolor.jflex
   //    $ javac Uncolor.java
   //    $ java Uncolor input.html
   %%

   %standalone

   %class Uncolor


   // HTML classes
   minicolorClasses           = "comment" | "keyword" | "literal"

   // Escaped symbols
   lt                         = "&lt;"
   gt                         = "&gt;"
   amp                        = "&amp;"

   // RegExp for removing html tags
   htmlTag                    = ("<html>"\n) | (\n"</html>")
   bodyTag                    = ("<body>"\n) | (\n"</body>")
   headTag                    = "<head>"\n (.|\n)* "</head>"\n
   spanTag                    = "<span class=\""{minicolorClasses}"\">" | "</span>"

   ignoreHtml                 = {htmlTag} | {bodyTag} | {headTag} | {spanTag}

   %%

   {ignoreHtml}   { /* ignore */ }

   {lt}           { System.out.print("<"); }
   {gt}           { System.out.print(">"); }
   {amp}          { System.out.print("&"); }

- When a mini source program is given to MiniColor, it generate some html. This
  html just wrap certain parts of the source input. If one were to remove the
  html tags, the original mini source program would remain. This is exactly the
  approach I took here. 

- The only expection is that MiniColor replace certain characters of the mini
  source program with html appropriate symbols. These characters need to be
  converted back to the original mini characters.

- See appendix A which include some test runs of the above program


Question 4: MiniColor Madness  [15 points]
------------------------------------------

      Match         | No Match
      --------------| ---------
         1          | 0
         10         | -1
         100        | 00
         2147483647 | 2147483648

