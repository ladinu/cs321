Question 1: Regular Expression Warmup [15 points]
-------------------------------------------------------------------------------

i)   Suppose you have a regular expression that contain n characters
     concatenated (see following table).

           n   | RegExp          | states in DFA | chars
        -------|-----------------|---------------|-----------------
           1   | "c"             |       2       |    1
           2   | "cc"            |       3       |    2
           3   | "ccc"           |       4       |    3
           4   | "cccc"          |       5       |    4
           .   | .               |       .       |    .
           .   | .               |       .       |    .
           .   | .               |       .       |    .
           n   | "c_1c_2...c_n"  |       n+1     |    n
     

     This would generate a DFA with n+1 states. First state will have a
     transition labeled by the first character of the regular expression to the
     second state and the second state will have a transition labeled by the second
     character of the regular expression to the third state and so on. The last
     state will be an accept state.

     To eliminate the +1 in n+1, one can modify the regular expression so that
     last character is optional. For example, "ccc*" (see table).

           n   | RegExp          | states in DFA | chars
        -------|-----------------|---------------|------------------
           1   | "c*"            |       1       |    1
           2   | "cc*"           |       2       |    2
           3   | "ccc*"          |       3       |    3
           4   | "cccc*"         |       4       |    4
           .   |   .             |       .       |    .
           .   |   .             |       .       |    .
           .   |   .             |       .       |    .
           n   | "c_1c_2...c_n*" |       n       |    n

     Because the last character of the RegExp is optional, the last state (the
     final state) will have a transition looping back to itself eliminating the need
     for an additional state. Now this RegExp has exactly n characters and n states
     and has only one accept state.




ii)  Because RegExp '%' cannot be used, RegExp '*' will be used to make a
     bigger RegExp in which the corresponding DFA will have all of its states be
     accepting states and will have n states. To construct this RegExp you must have
     n distinct characters. All distinct characters will be concatenated and each
     character is preceded by '*'. Consider the following table (note: each c_i is a
     distinct character):

          n   | RegExp                   | states in DFA | Accept States | chars
       -------|--------------------------|---------------|---------------|--------
          1   | "c_0**"                  |       1       |       1       |    1
          2   | "c_0*c_1*"               |       2       |       2       |    2
          3   | "c_0*c_1*c_2*"           |       3       |       3       |    3
          4   | "c_0*c_1*c_2*c_3*"       |       4       |       4       |    4
          .   |         .                |       .       |       .       |    .
          .   |         .                |       .       |       .       |    .
          .   |         .                |       .       |       .       |    .
          n   | "c_0*c_1*c_2*c_3*c_n*"   |       n       |       n       |    n





iii) To construct a RegExp that has exactly n characters and the corresponding
     DFA have only one state, you can have a character that is alternated with
     itself and the resulting regular expression alternated with the same character
     on and on until you have n characters. For example consider the following CFG
     and table that describe the regular expression:



         S => (c\|S)* | c*      // note: symbol '\|' represent ALT op. of RegExp



            n   | RegExp               | states in DFA  | chars
         -------|----------------------|----------------|---------------
            1   | "c*"                 |       1        |       1
            2   | "(c|c*)*"            |       1        |       2
            3   | "(c|(c|c*)*)*"       |       1        |       3
            4   | "(c|(c|(c|c*)*)*)*"  |       1        |       4
            .   |         .            |       .        |       .
            .   |         .            |       .        |       .
            .   |         .            |       .        |       .
            n   |         .            |       1        |       n

      
     The RegExp above, containing characters n >=1, will have exactly 1 state
     for its corresponding DFA.
         



iv)  Consider the table and CFG given below:

            n   | RegExp           | states in DFA  | Node in AST
         -------|------------------|----------------|---------------
            1   | "(c)*"           |       1        |       1
            2   | "(c*)*"          |       1        |       2
            3   | "((c*)*)*"       |       1        |       3
            4   | "(((c*)*))*"     |       1        |       4
            .   |         .        |       .        |       .
            .   |         .        |       .        |       .
            .   |         .        |       .        |       .
            n   |         .        |       1        |       n


            S => (S)* | c


      Because the RegExp contain only one character and that character is
      repeated, the corresponding DFA to the RegExp has a single state. The AST
      however has n nodes because '*' (repeat) symbol is nested. The 'Rep' node of
      the AST point to a regular expression node (including another 'Rep' node) that
      could be repeated. The AST for the given RegExp has multiple 'Rep' nodes
      pointing to each other and the last 'Rep' node pointing to 'c'.

         [Rep] -> [Rep] -> [Rep] -> ... -> [Rep] -> [c]



v)    The regular expression "((ab)*|a*)b" contain four characters and has 7
      states in its corresponding DFA.




Question 2: A Science Experiment  [10 points]
-------------------------------------------------------------------------------

- The potential performance problem with the given jflex program is that it
  match all data that ends with ABORT. If the file is too large and contain
  many unsuccessful runs of data before the ABORT line, the jflex buffer would
  not be able to contain all of the data.

- Assuming ABORT\n is not written to the file when a successful run is
  completed, more efficient program would match ABORT line, numeric data and the
  end of file (EOF). This would, of course, require a regular expression that
  would match "numeric" data. Another problem is that if the data in the
  successful run gets too big for the jflex buffer.


- I couldn't figure out how to do this in jflex.



Question 3: Syntax Uncoloring  [15 points]
-------------------------------------------------------------------------------

- The following jflex program convert html generated by MiniColor into plain
  text that contain the original mini program.

   // Given a HTML file that is generated from MiniColor,
   // this program remove all the HTML tags leaving only the 
   // original mini program
   //
   //    $ jflex Uncolor.jflex
   //    $ javac Uncolor.java
   //    $ java Uncolor input.html
   %%

   %standalone

   %class Uncolor


   // HTML classes
   minicolorClasses   = "comment" | "keyword" | "literal"

   // Escaped symbols
   lt                 = "&lt;"
   gt                 = "&gt;"
   amp                = "&amp;"

   // RegExp for removing html tags
   htmlTag            = ("<html>"\n) | (\n"</html>")
   bodyTag            = ("<body>"\n) | (\n"</body>")
   headTag            = "<head>"\n (.|\n)* "</head>"\n
   spanTag            = "<span class=\""{minicolorClasses}"\">" | "</span>"

   ignoreHtml         = {htmlTag} | {bodyTag} | {headTag} | {spanTag}

   %%

   {ignoreHtml}   { /* ignore */ }

   {lt}           { System.out.print("<"); }
   {gt}           { System.out.print(">"); }
   {amp}          { System.out.print("&"); }



- When a mini source program is given to MiniColor, it generate some html. This
  html just wrap certain parts of the source input. If one were to remove the
  html tags, the original mini source program would remain. This is exactly the
  approach I took here. 

- The only exception is that MiniColor replace certain characters of the mini
  source program with html appropriate symbols. These characters need to be
  converted back to the original mini characters.

- See appendix A which include some test runs of the above program


Question 4: MiniColor Madness  [15 points]
-------------------------------------------------------------------------------

a) The following jflex regular expressions match decimal integer literal that
   are between 1 and 999999999. The first RegExp match any digit from 0...9. The
   second RegExp match positive digits i.e 1...9. The third RegExp match positive
   numbers that has two digits. The fourth RegExp match digits that has three
   digits. This goes on and on until we are able to match numbers from 1 to
   999999999.

      d                = [0-9]
      posD             = [1-9]

      tens             = {posD}{d}
      hundreds         = {posD}{d}{d}
      thousands        = {posD}{d}{d}{d}
      tenThousands     = {posD}{d}{d}{d}{d}
      hundredThousands = {posD}{d}{d}{d}{d}{d}
      million          = {posD}{d}{d}{d}{d}{d}{d}
      tenMillion       = {posD}{d}{d}{d}{d}{d}{d}{d}
      hundredMillion   = {posD}{d}{d}{d}{d}{d}{d}{d}{d}

    The next set of regular expressions match numbers from 1000000000 through
    2147483647.

      match0           = 1{d}{d}{d}{d}{d}{d}{d}{d}{d}
      match1           = 2[0-0]{d}{d}{d}{d}{d}{d}{d}{d}
      match2           = 21[0-3]{d}{d}{d}{d}{d}{d}{d}
      match3           = 214[0-6]{d}{d}{d}{d}{d}{d}
      match4           = 2147[0-3]{d}{d}{d}{d}{d}
      match5           = 21474[0-7]{d}{d}{d}{d}
      match6           = 214748[0-2]{d}{d}{d}
      match7           = 2147483[0-5]{d}{d}
      match8           = 21474836[0-3]{d}
      match9           = 214748364[0-6]
      match10          = 2147483647


    The next RegExp combines previous regular expressions into one RegExp that
    match all positive numbers that are less than or equal to 2147483647


      literal = {posD}           | {tens}             | {hundreds} | {thousands}  |
                {tenThousands}   | {hundredThousands} | {million}  | {tenMillion} |
                {hundredMillion} | {match0}           | {match1}   | {match2}     |
                {match3}         | {match4}           | {match5}   | {match6}     |
                {match7}         | {match8}           | {match9}   | {match10}    



b)  Numbers 4 and 8 has one digit and are multiples of 4. The following numbers
    have two digits and are also multiples of 4 (note that 04, 08 and 00 are also
    multiples of 4 with two digits).  

         12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80,
         84, 88, 92, 96, 04, 08, 00

    All numbers that has 3 digits or more and are multiples of 4 has one of the
    above numbers as their last two digits. The following jflex RegExp match
    positive 1 digit numbers that are multiples of 4.

         "4" | "8"

    The following RegExp match all positive 2 digit numbers that are multiples
    of 4
      
         posTwoDigitMul4 = "12" | "16" | "20" | "24" | "28" | "32" | "36" | 
                           "40" | "44" | "48" | "52" | "56" | "60" | "64" | 
                           "68" | "72" | "76" | "80" | "84" | "88" | "92" | 
                           "96" | "04" | "08"

    The next RegExp match numbers that are two digits multiples of four which
    include 00.

         twoDigitMul4   = {posTwoDigitMul4} | "00"


    Finally, combining all of the abouve regular expressions gives us the
    RegExp that match any positive decimal integer that is a multiple of 4

         multiplesOf_4  = "4" | "8" | {posTwoDigitMul4} | [1-9][0-9]*{twoDigitMul4}
      

    See appendix B for the modified MiniColor program that tag positive numbers
    that are less than or equal to 2147483647 and are multiples of 4.





[ Appendix A ]
-------------------------------------------------------------------------------

 - The following jflex program (named Uncolor) was compiled

      // Given a HTML file that is generated from MiniColor,
      // this program remove all the HTML tags leaving only the 
      // original mini program
      //
      // Run using direction below:
      //
      //    $ jflex Uncolor.jflex
      //    $ javac Uncolor.java
      //    $ java Uncolor input.html
      %%

      %standalone

      %class Uncolor


      // HTML classes
      minicolorClasses           = "comment" | "keyword" | "literal"

      // Escaped symbols
      lt                         = "&lt;"
      gt                         = "&gt;"
      amp                        = "&amp;"

      // RegExp for removing html tags
      htmlTag                    = ("<html>"\n) | (\n"</html>")
      bodyTag                    = ("<body>"\n) | (\n"</body>")
      headTag                    = "<head>"\n (.|\n)* "</head>"\n
      spanTag                    = "<span class=\""{minicolorClasses}"\">" | "</span>"

      ignoreHtml                 = {htmlTag} | {bodyTag} | {headTag} | {spanTag}

      %%

      {ignoreHtml}   { /* ignore */ }

      {lt}           { System.out.print("<"); }
      {gt}           { System.out.print(">"); }
      {amp}          { System.out.print("&"); }

 - The following mini program was used for testing

      // A simple test
      // <span></span>;
      // int a = 0;

      int i, t;

      i = 1;
      t = 8;

      int <span> = 23

      while (i<10) {
        i = i + 1;
        t = t + i;
      }
      print t;


 - The following html was generated when the mini program was fed through
   MiniColor program.

      <html>
      <head>
      <title>My Syntax Colored Web Page</title>
      <style type="text/css">
        body     {white-space:pre;
                  background-color:#ffffcc;
                  color:black;
                  font-family:"Lucida Console","Courier New",Monotype}
        .keyword {color:blue}
        .comment {color:orange}
        .literal {color:green}
      </style>
      </head>
      <body>
      <span class="comment">// A simple test
      </span><span class="comment">// &lt;span&gt;&lt;/span&gt;;
      </span><span class="comment">// int a = 0;
      </span>
      <span class="keyword">int</span> i, t;

      i = <span class="literal">1</span>;
      t = <span class="literal">8</span>;

      <span class="keyword">int</span> &lt;span&gt; = <span class="literal">23</span>

      <span class="keyword">while</span> (i&lt;<span class="literal">10</span>) {
        i = i + <span class="literal">1</span>;
        t = t + i;
      }
      <span class="keyword">print</span> t;
      </body>
      </html>

 - When Uncolor program was given the above html, the original mini program was
   printed out.

      / A simple test
      // <span></span>;
      // int a = 0;

      int i, t;

      i = 1;
      t = 8;

      int <span> = 23

      while (i<10) {
        i = i + 1;
        t = t + i;
      }
      print t;


 - Following are more tests that were run. The order of each test was same as
   above: input.minit --> MiniColor --> out.html --> Uncolor --> out.mini

   Test 1:

   <
   >
   &

   html>
   <head>
   <title>My Syntax Colored Web Page</title>
   <style type="text/css">
     body     {white-space:pre;
               background-color:#ffffcc;
               color:black;
               font-family:"Lucida Console","Courier New",Monotype}
     .keyword {color:blue}
     .comment {color:orange}
     .literal {color:green}
     .invalid {color:red}
     .multiple {font-weight: bold}
   </style>
   </head>
   <body>
   &lt;
   &gt;
   &amp;
   </body>
   </html>

   <
   >
   &

   Test 2:

   //
   while
   23

   html>
   <head>
   <title>My Syntax Colored Web Page</title>
   <style type="text/css">
     body     {white-space:pre;
               background-color:#ffffcc;
               color:black;
               font-family:"Lucida Console","Courier New",Monotype}
     .keyword {color:blue}
     .comment {color:orange}
     .literal {color:green}
     .invalid {color:red}
     .multiple {font-weight: bold}
   </style>
   </head>
   <body>
   <span class="comment">//
   </span><span class="keyword">while</span>
   <span class="literal">23</span>
   </body>
   </html>


   //
   while
   23


[ Appendix B]
-------------------------------------------------------------------------------

// 10 jflex can be used to build useful utilities!

/** This is an example of a syntax coloring program for the mini
 *  programming language that has been written using the jflex
 *  lexical analyzer generator (see http://www.jflex.de).
 */

%%

// We use the %standalone declaration, which tells jflex that we want to
// build a self-contained program.  This will result in the definition of a
// main function that reads a file name on the command line and then passes
// all of the text from that file through the generated scanner/lexer.  We
// will produce the corresponding syntax colored output simply by printing
// it on to the standard output device; this makes it easy to inspect the
// output while debugging, but we can also use a redirect operator to
// save the contents in an HTML file instead that is suitable for viewing
// in a browser.

%standalone

// Next, we use the %class declaration, selecting MiniColor as the name
// for the Java class that will be generated:

%class MiniColor

// Assuming that the JFlex source shown here is stored in MiniColor.jflex,
// we will now be able to generate and compile our program using the
// following commands:
// 
//   jflex MiniColor.jflex 
//   javac MiniColor.java
//
// The resulting program can then be run as follows:
//   
//   java MiniColor squares.mini  > sq.html

// Every HTML file that we generate should begin with set of lines to set
// basic details such as the title and the style options.  The %init
// feature of jflex provides An easy way to handle this, allowing us to
// specify some code that should be executed as part of the constructor for
// the MiniColor constructor; in this case, we just need to print the
// initial set of lines for the start of the HTML output.  (This would also
// be a good place to initialize an output file if we wanted to write the
// output from the program directly to a file instead of just printing it
// on the standard output.)

%init{
  System.out.println("<html>");
  System.out.println("<head>");
  System.out.println("<title>My Syntax Colored Web Page</title>");
  System.out.println("<style type=\"text/css\">");
  System.out.println("  body     {white-space:pre;");
  System.out.println("            background-color:#ffffcc;");
  System.out.println("            color:black;");
  System.out.println("            font-family:\"Lucida Console\",\"Courier New\",Monotype}");
  System.out.println("  .keyword {color:blue}");
  System.out.println("  .comment {color:orange}");
  System.out.println("  .literal {color:green}");
  System.out.println("  .invalid {color:red}");
  System.out.println("  .multiple {font-weight: bold}");
  System.out.println("</style>");
  System.out.println("</head>");
  System.out.println("<body>");
%init}

// There is a similar %eof feature that allows us to specify code that
// will be executed when the program reaches the end of the input file.
// This provides a convenient place for us to put the code that produces
// the HTML lines that are required at the end of every output file:

%eof{
  System.out.println("</body>");
  System.out.println("</html>");
%eof}

// In general, our syntax coloring program will work by matching
// patterns in the input file and then outputing the original lexeme,
// sometimes wrapped between HTML tags to specify how the lexeme
// should be colored.  One small technical challenge in this is that
// we need to make sure that the three characters <, >, and &, which
// have special uses in HTML, are replaced by the appropriate escape
// sequences &lt;, &gt:, and &amp;, respectively in the output.
// In principle, it would be possible to handle this completely within
// the main set of jflex matching rules.  However, in this particular
// case, it seems easier (at least to this author) just to handle
// this with a little bit of Java code as shown in the following
// echo() function.  This function works by reading characters one
// at a time from the internal buffer that JFlex uses, checking for
// the three special cases, and performing the necessary output
// action each time.

%{
  void echo() {
    int len = yylength();       // Find length of current lexeme
    for (int i=0; i<len; i++) { // Run through each character in turn
      char c = yycharat(i);   
      switch (c) {              // and translate as appropriate ...
        case '<' : System.out.print("&lt;");  break;
        case '>' : System.out.print("&gt;");  break;
        case '&' : System.out.print("&amp;"); break;
        default  : System.out.print(c);       break;
      }
    }
  }
%}

// As a small technical aside, note that we have used a combination
// of the yylength() and yycharat() functions to access the text of
// the current lexeme.  We could achieve a similar effect using the
// yytext() function, but the approach used here is faster (at least
// in principle) because it avoids the overheads of constructing a
// new string object for each input element.

// The echo() method described above is good for printing the text
// of a lexeme directly, without any special syntax coloring.  For
// lexemes where we want to add some color, however, we can use the
// following tag() method, which adds an appropriate span tag before
// and after the lexeme text.

%{
  void tag(String cl) {
    System.out.print("<span class=\"" + cl + "\">");
    echo();
    System.out.print("</span>");
  }
%}

// The parameter cl is used to specify a particular token class/style;
// given the opening lines of HTML shown above, this should be one of
// "keyword", "comment", "literal", or "invalid".  We can define some
// quick helper methods for each of these four cases as follows:

%{
  void keyword()     { tag("keyword"); }
  void comment()     { tag("comment"); }
  void literal()     { tag("literal"); }
  void invalid_lit() { tag("invalid"); }
  void invalid()     { tag("invalid"); }
%}

// Now we are ready to give regular expressions for each of the input
// elements that can appear in a valid mini program.  We will use the
// following rules to specify the syntax of identifiers, whitespace,
// and comments:

Identifier         = [:jletter:] [:jletterdigit:]*

LineTerminator     = \r|\n|\r\n
WhiteSpace         = {LineTerminator} | [ \t\f] 
InputCharacter     = [^\r\n]

Comment            = {TraditionalComment} | {EndOfLineComment}
TraditionalComment = "/*" [^*] ~"*/" | "/*" "*"+ "/"
EndOfLineComment   = "//" {InputCharacter}* {LineTerminator}

// All that remains now is to define some rules for matching the different
// tokens that can appear in a valid mini program with corresponding actions
// to generate the appropriate output in each case.  As such, this puts us
// into the last section of our jflex input file:

posD             = [1-9]
d                = [0-9]

tens             = {posD}{d}
hundreds         = {posD}{d}{d}
thousands        = {posD}{d}{d}{d}
tenThousands     = {posD}{d}{d}{d}{d}
hundredThousands = {posD}{d}{d}{d}{d}{d}
million          = {posD}{d}{d}{d}{d}{d}{d}
tenMillion       = {posD}{d}{d}{d}{d}{d}{d}{d}
hundredMillion   = {posD}{d}{d}{d}{d}{d}{d}{d}{d}

match0           = 1{d}{d}{d}{d}{d}{d}{d}{d}{d}
match1           = 2[0-0]{d}{d}{d}{d}{d}{d}{d}{d}
match2           = 21[0-3]{d}{d}{d}{d}{d}{d}{d}
match3           = 214[0-6]{d}{d}{d}{d}{d}{d}
match4           = 2147[0-3]{d}{d}{d}{d}{d}
match5           = 21474[0-7]{d}{d}{d}{d}
match6           = 214748[0-2]{d}{d}{d}
match7           = 2147483[0-5]{d}{d}
match8           = 21474836[0-3]{d}
match9           = 214748364[0-6]
match10          = 2147483647


invalid_lit_0    = 0
invalid_lit_1    = 214748364[8-9]
invalid_lit_2    = 21474836[5-9]{d}
invalid_lit_3    = 2147483[7-9]{d}{d}
invalid_lit_4    = 214748[4-9]{d}{d}{d}
invalid_lit_5    = 21474[9-9]{d}{d}{d}{d}
invalid_lit_6    = 2147[5-9]{d}{d}{d}{d}{d}
invalid_lit_7    = 214[8-9]{d}{d}{d}{d}{d}{d}
invalid_lit_8    = 21[5-9]{d}{d}{d}{d}{d}{d}{d}
invalid_lit_9    = 2[2-9]{d}{d}{d}{d}{d}{d}{d}{d}
invalid_lit_10   = [3-9]{d}{d}{d}{d}{d}{d}{d}{d}{d}
invalid_lit_11   = {d}{d}{d}{d}{d}{d}{d}{d}{d}{d}*

// RegExps for matching positive ints that are multiples of 4
// For ints that have 3 or more digits, the last two digit is 
// goung to be a pattern. This pattern is all the multiples of 4
// which have 1 or 2 digits i.e {4, 8, 12, 16, 20, 24, ..., 96}

posTwoDigitMul4 = "12" | "16" | "20" | "24" | "28" | "32" | "36" | 
                  "40" | "44" | "48" | "52" | "56" | "60" | "64" | 
                  "68" | "72" | "76" | "80" | "84" | "88" | "92" | 
                  "96" | "04" | "08"

twoDigitMul4   = {posTwoDigitMul4} | "00"

multiplesOf_4  = "4" | "8" | {posTwoDigitMul4} | [1-9][0-9]*{twoDigitMul4}


// Combine 
invalid_lit    = {invalid_lit_0} | {invalid_lit_1}  | {invalid_lit_2}  |
                 {invalid_lit_3} | {invalid_lit_4}  | {invalid_lit_5}  |
                 {invalid_lit_6} | {invalid_lit_7}  | {invalid_lit_8}  |
                 {invalid_lit_9} | {invalid_lit_10} | {invalid_lit_11}

literal        = {posD}           | {tens}             | {hundreds} | {thousands}  |
                 {tenThousands}   | {hundredThousands} | {million}  | {tenMillion} |
                 {hundredMillion} | {match0}           | {match1}   | {match2}     |
                 {match3}         | {match4}           | {match5}   | {match6}     |
                 {match7}         | {match8}           | {match9}   | {match10}    |
                 {multiplesOf_4}

%%

// Once again, we can adopt the definitions for mini tokens that were
// provided in the original mini lexer.  We group the tokens here so
// that multiple patterns can be combined into a single regular expression
// and then share a single action.

// Basic punctuation and operator symbols are echoed directly to the output
// without any syntax coloring:

","  | "["  | "]"  | "("  | ")"  | "{"  | "}" | ";" |
"="  | "==" | ">"  | ">=" | "<"  | "<=" | "!" | "~" |
"!=" | "&"  | "&&" | "|"  | "||" | "^"  | "*" | "+" |
"-" | "/"       { echo(); }

// Keywords are matched and displayed using "keyword" tag:

"int"   | "boolean" | "while" |
"if"    | "else"    | "print"
                { keyword(); }


// Integer literals are matched and displayed using the "literal" tag:
{literal}       { literal(); }


// Mark numbers bigger than 2147483647 as invalid

{invalid_lit}   { invalid_lit(); }


// Comments are matched and displayed using the "comment" tag:

{Comment}       { comment(); }

// Finally, identifiers and whitespace are output without any coloring
// annotations.  We could have combined these regular expressions with each
// other and with the rule for punctuation given previously.  However, we
// have chosen not to do that.  One reason is that there is at least a
// conceptual difference between these types of input elements (even if they
// are colored in the same way).  A second reason is that we want to make
// sure the rule for identifiers comes after the rule for keywords to ensure
// that keywords are colored using the earlier rule.

{Identifier}    { echo(); }
{WhiteSpace}    { echo(); }

// This completes the list of all valid tokens that can appear in a mini
// program, but we will end our list of lexer rules with a catch all that
// matches any input not already matched and aborts the program with an
// "Invalid input" error.

.|\n            { System.err.println("Invalid input");
                  System.exit(1);
                }

// 


- After feeding the following mini program the following html was generated by
  MiniColor

   Test mini program:

   // A simple test
   // <span></span>;
   // int a = 0;
   int <span> = 2147483647;
   int <span> = 2147483648;
   int i, t;
   i = -1;
   t = 8;


   2147483647296
   2147483649
   [0, 00, 1, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 
    48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92,
    96, 100, 104, 108, 112, 116, 120, 124, 128, 132,
    136, 140, 144, 148, 152, 156, 160, 164, 168, 172,
    176, 180, 184, 188, 192, 196, 200, 204, 208, 212,
    216, 220, 224, 228, 232, 236, 240, 244, 248, 252,
    256, 260, 264, 268, 272, 276, 280, 284, 288, 292,
    296, 300, 304, 308, 312, 316, 320, 324, 328, 332,
    336, 340, 344, 348, 352, 356, 360, 364, 368, 372, 
    376, 380, 384, 388, 392, 396]



   312, 3316, 3320, 3324, 3328, 3332, 3336
   3340, 3344, 3348, 3352, 3356, 3360, 3364
   3368, 3372, 3376, 3380, 3384, 3388, 3392
   3396, 3400, 3404, 3408, 3412, 3416, 3420
   3424, 3428, 3432, 3436, 3440, 3444, 3448
   3452, 3456, 3460, 3464, 3468, 3472, 3476
   3480, 3484, 3488, 3492, 3496, 3500, 3504
   3508, 3512, 3516, 3520, 3524, 3528, 3532
   3536, 3540, 3544, 3548, 3552, 3556, 3560
   3564, 3568, 3572, 3576, 3580, 3584, 3588
   3592, 3596, 3600, 3604, 3608, 3612, 3616
   3620, 3624, 3628, 3632, 3636, 3640, 3644
   3648, 3652, 3656, 3660, 3664, 3668, 3672
   3676, 3680, 3684, 3688, 3692, 3696, 3700
   3704, 3708, 3712, 3716, 3720, 3724, 3728
   3732, 3736, 3740, 3744, 3748, 3752, 3756
   3760, 3764, 3768, 3772, 3776, 3780, 3784
   3788, 3792, 3796, 3800, 3804, 3808, 3812
   3816, 3820, 3824, 3828, 3832, 3836, 3840
   3844, 3848, 3852, 3856, 3860, 3864, 3868
   3872, 3876, 3880, 3884, 3888, 3892, 3896
   3900, 3904, 3908, 3912, 3916, 3920, 3924
   3928, 3932, 3936, 3940, 3944, 3948, 3952
   3956, 3960, 3964, 3968, 3972, 3976, 3980
   3984, 3988, 3992, 3996]

   while (i<10) {
     i = i + 1;
     t = t + i;
   }
   print t;

   Generated html (note: the html was wrapped to fit the width of this document):


   <html>
   <head>
   <title>My Syntax Colored Web Page</title>
   <style type="text/css">
     body     {white-space:pre;
               background-color:#ffffcc;
               color:black;
               font-family:"Lucida Console","Courier New",Monotype}
     .keyword {color:blue}
     .comment {color:orange}
     .literal {color:green}
     .invalid {color:red}
     .multiple {font-weight: bold}
   </style>
   </head>
   <body>
   <span class="comment">// A simple test
   </span><span class="comment">// &lt;span&gt;&lt;/span&gt;;
   </span><span class="comment">// int a = 0;
   </span><span class="keyword">int</span> &lt;span&gt; = <span
   class="literal">2147483647</span>;
   <span class="keyword">int</span> &lt;span&gt; = <span
   class="literal">2147483648</span>;
   <span class="keyword">int</span> i, t;
   i = -<span class="literal">1</span>;
   t = <span class="literal">8</span>;


   <span class="literal">2147483647296</span> <span
   class="invalid">2147483649</span> [<span class="invalid">0</span>, <span
   class="invalid">0</span><span class="invalid">0</span>, <span
   class="literal">1</span>, <span class="literal">4</span>, <span
   class="literal">8</span>, <span class="literal">12</span>, <span
   class="literal">16</span>, <span class="literal">20</span>, <span
   class="literal">24</span>, <span class="literal">28</span>, <span
   class="literal">32</span>, <span class="literal">36</span>, <span
   class="literal">40</span>, <span class="literal">44</span>, <span
   class="literal">48</span>, <span class="literal">52</span>, <span
   class="literal">56</span>, <span class="literal">60</span>, <span
   class="literal">64</span>, <span class="literal">68</span>, <span
   class="literal">72</span>, <span class="literal">76</span>, <span
   class="literal">80</span>, <span class="literal">84</span>, <span
   class="literal">88</span>, <span class="literal">92</span>, <span
   class="literal">96</span>, <span class="literal">100</span>, <span
   class="literal">104</span>, <span class="literal">108</span>, <span
   class="literal">112</span>, <span class="literal">116</span>, <span
   class="literal">120</span>, <span class="literal">124</span>, <span
   class="literal">128</span>, <span class="literal">132</span>, <span
   class="literal">136</span>, <span class="literal">140</span>, <span
   class="literal">144</span>, <span class="literal">148</span>, <span
   class="literal">152</span>, <span class="literal">156</span>, <span
   class="literal">160</span>, <span class="literal">164</span>, <span
   class="literal">168</span>, <span class="literal">172</span>, <span
   class="literal">176</span>, <span class="literal">180</span>, <span
   class="literal">184</span>, <span class="literal">188</span>, <span
   class="literal">192</span>, <span class="literal">196</span>, <span
   class="literal">200</span>, <span class="literal">204</span>, <span
   class="literal">208</span>, <span class="literal">212</span>, <span
   class="literal">216</span>, <span class="literal">220</span>, <span
   class="literal">224</span>, <span class="literal">228</span>, <span
   class="literal">232</span>, <span class="literal">236</span>, <span
   class="literal">240</span>, <span class="literal">244</span>, <span
   class="literal">248</span>, <span class="literal">252</span>, <span
   class="literal">256</span>, <span class="literal">260</span>, <span
   class="literal">264</span>, <span class="literal">268</span>, <span
   class="literal">272</span>, <span class="literal">276</span>, <span
   class="literal">280</span>, <span class="literal">284</span>, <span
   class="literal">288</span>, <span class="literal">292</span>, <span
   class="literal">296</span>, <span class="literal">300</span>, <span
   class="literal">304</span>, <span class="literal">308</span>, <span
   class="literal">312</span>, <span class="literal">316</span>, <span
   class="literal">320</span>, <span class="literal">324</span>, <span
   class="literal">328</span>, <span class="literal">332</span>, <span
   class="literal">336</span>, <span class="literal">340</span>, <span
   class="literal">344</span>, <span class="literal">348</span>, <span
   class="literal">352</span>, <span class="literal">356</span>, <span
   class="literal">360</span>, <span class="literal">364</span>, <span
   class="literal">368</span>, <span class="literal">372</span>, <span
   class="literal">376</span>, <span class="literal">380</span>, <span
   class="literal">384</span>, <span class="literal">388</span>, <span
   class="literal">392</span>, <span class="literal">396</span>]



   <span class="literal">312</span>, <span class="literal">3316</span>, <span
   class="literal">3320</span>, <span class="literal">3324</span>, <span
   class="literal">3328</span>, <span class="literal">3332</span>, <span
   class="literal">3336</span> <span class="literal">3340</span>, <span
   class="literal">3344</span>, <span class="literal">3348</span>, <span
   class="literal">3352</span>, <span class="literal">3356</span>, <span
   class="literal">3360</span>, <span class="literal">3364</span> <span
   class="literal">3368</span>, <span class="literal">3372</span>, <span
   class="literal">3376</span>, <span class="literal">3380</span>, <span
   class="literal">3384</span>, <span class="literal">3388</span>, <span
   class="literal">3392</span> <span class="literal">3396</span>, <span
   class="literal">3400</span>, <span class="literal">3404</span>, <span
   class="literal">3408</span>, <span class="literal">3412</span>, <span
   class="literal">3416</span>, <span class="literal">3420</span> <span
   class="literal">3424</span>, <span class="literal">3428</span>, <span
   class="literal">3432</span>, <span class="literal">3436</span>, <span
   class="literal">3440</span>, <span class="literal">3444</span>, <span
   class="literal">3448</span> <span class="literal">3452</span>, <span
   class="literal">3456</span>, <span class="literal">3460</span>, <span
   class="literal">3464</span>, <span class="literal">3468</span>, <span
   class="literal">3472</span>, <span class="literal">3476</span> <span
   class="literal">3480</span>, <span class="literal">3484</span>, <span
   class="literal">3488</span>, <span class="literal">3492</span>, <span
   class="literal">3496</span>, <span class="literal">3500</span>, <span
   class="literal">3504</span> <span class="literal">3508</span>, <span
   class="literal">3512</span>, <span class="literal">3516</span>, <span
   class="literal">3520</span>, <span class="literal">3524</span>, <span
   class="literal">3528</span>, <span class="literal">3532</span> <span
   class="literal">3536</span>, <span class="literal">3540</span>, <span
   class="literal">3544</span>, <span class="literal">3548</span>, <span
   class="literal">3552</span>, <span class="literal">3556</span>, <span
   class="literal">3560</span> <span class="literal">3564</span>, <span
   class="literal">3568</span>, <span class="literal">3572</span>, <span
   class="literal">3576</span>, <span class="literal">3580</span>, <span
   class="literal">3584</span>, <span class="literal">3588</span> <span
   class="literal">3592</span>, <span class="literal">3596</span>, <span
   class="literal">3600</span>, <span class="literal">3604</span>, <span
   class="literal">3608</span>, <span class="literal">3612</span>, <span
   class="literal">3616</span> <span class="literal">3620</span>, <span
   class="literal">3624</span>, <span class="literal">3628</span>, <span
   class="literal">3632</span>, <span class="literal">3636</span>, <span
   class="literal">3640</span>, <span class="literal">3644</span> <span
   class="literal">3648</span>, <span class="literal">3652</span>, <span
   class="literal">3656</span>, <span class="literal">3660</span>, <span
   class="literal">3664</span>, <span class="literal">3668</span>, <span
   class="literal">3672</span> <span class="literal">3676</span>, <span
   class="literal">3680</span>, <span class="literal">3684</span>, <span
   class="literal">3688</span>, <span class="literal">3692</span>, <span
   class="literal">3696</span>, <span class="literal">3700</span> <span
   class="literal">3704</span>, <span class="literal">3708</span>, <span
   class="literal">3712</span>, <span class="literal">3716</span>, <span
   class="literal">3720</span>, <span class="literal">3724</span>, <span
   class="literal">3728</span> <span class="literal">3732</span>, <span
   class="literal">3736</span>, <span class="literal">3740</span>, <span
   class="literal">3744</span>, <span class="literal">3748</span>, <span
   class="literal">3752</span>, <span class="literal">3756</span> <span
   class="literal">3760</span>, <span class="literal">3764</span>, <span
   class="literal">3768</span>, <span class="literal">3772</span>, <span
   class="literal">3776</span>, <span class="literal">3780</span>, <span
   class="literal">3784</span> <span class="literal">3788</span>, <span
   class="literal">3792</span>, <span class="literal">3796</span>, <span
   class="literal">3800</span>, <span class="literal">3804</span>, <span
   class="literal">3808</span>, <span class="literal">3812</span> <span
   class="literal">3816</span>, <span class="literal">3820</span>, <span
   class="literal">3824</span>, <span class="literal">3828</span>, <span
   class="literal">3832</span>, <span class="literal">3836</span>, <span
   class="literal">3840</span> <span class="literal">3844</span>, <span
   class="literal">3848</span>, <span class="literal">3852</span>, <span
   class="literal">3856</span>, <span class="literal">3860</span>, <span
   class="literal">3864</span>, <span class="literal">3868</span> <span
   class="literal">3872</span>, <span class="literal">3876</span>, <span
   class="literal">3880</span>, <span class="literal">3884</span>, <span
   class="literal">3888</span>, <span class="literal">3892</span>, <span
   class="literal">3896</span> <span class="literal">3900</span>, <span
   class="literal">3904</span>, <span class="literal">3908</span>, <span
   class="literal">3912</span>, <span class="literal">3916</span>, <span
   class="literal">3920</span>, <span class="literal">3924</span> <span
   class="literal">3928</span>, <span class="literal">3932</span>, <span
   class="literal">3936</span>, <span class="literal">3940</span>, <span
   class="literal">3944</span>, <span class="literal">3948</span>, <span
   class="literal">3952</span> <span class="literal">3956</span>, <span
   class="literal">3960</span>, <span class="literal">3964</span>, <span
   class="literal">3968</span>, <span class="literal">3972</span>, <span
   class="literal">3976</span>, <span class="literal">3980</span> <span
   class="literal">3984</span>, <span class="literal">3988</span>, <span
   class="literal">3992</span>, <span class="literal">3996</span>]

   <span class="keyword">while</span> (i&lt;<span class="literal">10</span>) {
     i = i + <span class="literal">1</span>;
     t = t + i;
   }
   <span class="keyword">print</span> t;
   </body>
   </html>
---------------------------------------------------------------------
