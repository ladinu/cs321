Question 1: Regular Expression Warmup [15 points]
-------------------------------------------------

i) Suppose you have a regular expression that contain n characters
   concatinated (see following table).

         n   | RegExp       | states in DFA
      -------|--------------|-------------------------
         1   | "c"          | 2
         2   | "cc"         | 3
         3   | "ccc"        | 4
         4   | "cccc"       | 5
         .   | .            | .
         .   | .            | .
         .   | .            | .
         n   | "c1c2...cn"  | n+1
   

   This would generate a DFA with n+1 states. First state will have a
   transition labled by the first character of the regular expression to the
   skecond state and the second state will have a transition labled by the second
   character of the regular expression to the third state and so on. The last
   state will be an accept state.

   To eliminate the +1 in n+1, one can modify the regular expression so that
   last character is optional. For example, "ccc*" (see table).

         n   | RegExp       | states in DFA
      -------|--------------|-------------------------
         1   | "c*"         | 1
         2   | "cc*"        | 2
         3   | "ccc*"       | 3
         4   | "cccc*"      | 4
         .   |   .          | .
         .   |   .          | .
         .   |   .          | .
         n   | "c1c2...cn*" | n

   Because the last character of the RegExp is optional, the last state (the
   final state) will have a transition looping back to itself eliminating the need
   for an additional state. Now this RegExp has exactly n characters and n states
   and has only one accept state.


ii) In part i I constructed a RegExp that has n characters and exactly n states
    with one accept state. To create a RegExp that has n characters and exactly n
    states and all states are accepting states I will modify the RegExp from part
    i. 

    If I alternate each character of RegExp given in part i with the empty
    string, the resulting DFA will have all of its state be accepting states
    because it will have to accept the empty string.

         n   | RegExp                    | states in DFA  | Accept States
      -------|---------------------------|----------------|---------------
         1   | "(c|%)*"                  |       1        |       1
         2   | "(c|%)(c|%)*"             |       2        |       2
         3   | "(c|%)(c|%)(c|%)*"        |       3        |       3
         4   | "(c|%)(c|%)(c|%)(c|%)*"   |       4        |       4 
         .   |         .                 |       .        |       .
         .   |         .                 |       .        |       .
         .   |         .                 |       .        |       .
         n   | "(c1|%)(c2|%)...(cn|%)*"  |       n        |       n

iii) (c|c|c|c)*

iv) (c)*, (c*)*, ((c*)*)*, ...

v) 


Question 2: A Science Experiment  [10 points]
---------------------------------------------

- The potential perforamnce problem with the given jflex program is that it
  starts at the top of the file and tries to match the given pattern
  "(.|\n)*ABORT\n". This can be expensive if the file is large and contain many
  failures which are marked as "ABORT".

- Assuming nothing (other than data) is written to the file when a sucessful
  run is completed, more eficent program would start looking at the file from
  the bottom and continue up untill it sees a "ABORT" flag. Now everything below
  this flag can be presented and aeverything above ignored.

- The following is a jflex program that solves this problem:


Question 3: Syntax Uncoloring  [15 points]
------------------------------------------

- The following jflex program convert html generated by MiniColor into plain
  text that contain the original mini program.

   // Given a HTML file that is generated from MiniColor,
   // this program remove all the HTML tags leaving only the 
   // original mini program
   //
   //    $ jflex Uncolor.jflex
   //    $ javac Uncolor.java
   //    $ java Uncolor input.html
   %%

   %standalone

   %class Uncolor


   // HTML classes
   minicolorClasses           = "comment" | "keyword" | "literal"

   // Escaped symbols
   lt                         = "&lt;"
   gt                         = "&gt;"
   amp                        = "&amp;"

   // RegExp for removing html tags
   htmlTag                    = ("<html>"\n) | (\n"</html>")
   bodyTag                    = ("<body>"\n) | (\n"</body>")
   headTag                    = "<head>"\n (.|\n)* "</head>"\n
   spanTag                    = "<span class=\""{minicolorClasses}"\">" | "</span>"

   ignoreHtml                 = {htmlTag} | {bodyTag} | {headTag} | {spanTag}

   %%

   {ignoreHtml}   { /* ignore */ }

   {lt}           { System.out.print("<"); }
   {gt}           { System.out.print(">"); }
   {amp}          { System.out.print("&"); }

- When a mini source program is given to MiniColor, it generate some html. This
  html just wrap certain parts of the source input. If one were to remove the
  html tags, the original mini source program would remain. This is exactly the
  approach I took here. 

- The only expection is that MiniColor replace certain characters of the mini
  source program with html appropriate symbols. These characters need to be
  converted back to the original mini characters.

- See appendix A which include some test runs of the above program


Question 4: MiniColor Madness  [15 points]
------------------------------------------

      Match         | No Match
      --------------| ---------
         1          | 0
         10         | -1
         100        | 00
         2147483647 | 2147483648

