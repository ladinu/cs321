// This is supporting software for CS321 Compilers and Language Design I
// Copyright (c) Portland State University
// 
//----------------------------------------------------------------------
// An starting program for miniJava Parser.
//
// For CS321 HW4, W'14
//
// Instructions:
//
// 1. Copy or rename this file to 'mjParser.jj'.
// 2. Add parsing routines to the parser section (either copy from your 
//    'mjGrammarLL.jj' program or convert from 'mjGrammarLL2.txt'.
// 3. Insert semantic actions into the parsing routines.
//----------------------------------------------------------------------
//
//

// options { DEBUG_PARSER=true; }  /* Show debugging info */

PARSER_BEGIN(mjParser)
import java.util.*;
import java.io.*;
import ast.*;

public class mjParser {
  public static void main(String [] args) {
    try {
      if (args.length == 1) {
	FileInputStream stream = new FileInputStream(args[0]);
	Ast.Exp p = new mjParser(stream).Program();
	stream.close();
	System.out.println(p);
      } else {
	System.out.print("Need a file name as command-line argument.\n");
      }
    } catch (TokenMgrError e) {
      System.err.println(e);
    } catch (Exception e) {
      System.err.println(e);
    }
  }
}
PARSER_END(mjParser)

//
// LEXER SECTION ---------------------------------------------------------------
//

SKIP : /* White space */
{
  " " | "\t" | "\n" | "\r" | "\f"
}

SKIP : /* Comments */
{
  <SLComment:    "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <MLComment:    "/*" ( ~["*"] | (["*"])+ (~["/"]) )* (["*"])+ "/">
| <Unterminated: "/*" ( ~["*"] | (["*"])+ (~["/"]) )* (["*"])+ >
    { if (true) throw new TokenMgrError("Unterminated multi-line comments ", 0); }  
}

TOKEN : /* Keywords */
{
  <kwBoolean: "boolean">   
| <kwClass:   "class">
| <kwElse:    "else">
| <kwExtends: "extends">
| <kwIf:      "if">
| <kwInt:     "int">
| <kwMain:    "main">
| <kwNew:     "new">
| <kwPublic:  "public">
| <kwReturn:  "return">
| <kwStatic:  "static">
| <kwString:  "String">
| <kwPrint:   "System.out.println">
| <kwThis:    "this">
| <kwVoid:    "void">         
| <kwWhile:   "while">
| <#Digit:    ["0"-"9"]>
| <#Letter:   (["A"-"Z"]|["a"-"z"])>
}

TOKEN : /* BoolLit */
{
  <BoolLit: "true"|"false">
}

TOKEN : /* IntLit */
{
  <IntLit: (<Digit>)+> 
  { try { 
      Integer.parseInt(matchedToken.image); 
    } catch (Exception e) { 
      throw new TokenMgrError("Lexical error at line " + matchedToken.beginLine + 
			      ", column " + matchedToken.beginColumn + 
			      ". Integer overflow: " + matchedToken.image, 0);
    } 
  }
}

TOKEN : /* StrLit */
{
  <StrLit: ("\"" (~["\"","\n"])+ "\"")>
  { if (matchedToken.image.length() > 257) 
      throw new TokenMgrError("Lexical error at line " + matchedToken.beginLine + 
			      ", column " + matchedToken.beginColumn + 
			      ". String length over 255: " + matchedToken.image, 0); 
  }
}

TOKEN : /* Id */
{
  <Id: <Letter> (<Letter>|<Digit>|"_")*>
  { if (matchedToken.image.length() > 255) 
      throw new TokenMgrError("Lexical error at line " + matchedToken.beginLine + 
			      ", column " + matchedToken.beginColumn + 
			      ". Id length over 255: " + matchedToken.image, 0);
  }
}

// Operators and Delimiters are not explicitly defined:
//
// Operators:  "="|"+"|"-"|"*"|"/"|"&&"|"||"|"!"|"=="|"!="|"<"|"<="|">"|">="
// Delimiters: ";"|","|"."|"("|")"|"["|"]"|"{"|"}"
//


//
// PARSER SECTION ---------------------------------------------------------------
//

Ast.Exp Program():
{
   Ast.Exp factor;
}
{
   factor=PrintArg() <EOF>
   {return factor;}
}


Ast.Exp PrintArg():
{
   Ast.Exp e; String s = null;
}
{
   ( LOOKAHEAD(2) e=Expr() | s=StrLit() {e = new Ast.StrLit(s); })
   { return e; }
}

Ast.Exp InitExpr():
{
   Ast.Exp e;
   Ast.Type t;
   Ast.Id id;
   int idx;
   List<Ast.Exp> args = new ArrayList<Ast.Exp>();
}
{
   ( "new" ( t=BasicType() "[" idx=IntLit() "]" { e = new Ast.NewArray(t, idx);}
           | id=Id() "(" [args=Args()] ")" { e = new Ast.NewObj(id.nm, args);})
   | e=Expr())

   { return e; }
}

Ast.Exp Expr():
{ Ast.Exp e1, e2; }
{
   e1=AndExpr() ( "||" e2=AndExpr() {e1 = new Ast.Binop(Ast.BOP.OR, e1, e2);})*
   { return e1; }
}

Ast.Exp AndExpr():
{ Ast.Exp e1, e2; }
{
   e1=RelExpr() ( "&&" e2=RelExpr() {e1 = new Ast.Binop(Ast.BOP.AND, e1, e2);})*
   {return e1; }
}

Ast.Exp RelExpr():
{ Ast.Exp e1, e2; Ast.BOP op; }
{
   e1=ArithExpr() ( op=RelOp() e2=ArithExpr() {e1 = new Ast.Binop(op, e1, e2);})*
   {return e1; }
}

Ast.Exp ArithExpr():
{ Ast.Exp e1, e2; Ast.BOP op; }
{
   e1=Term() ( op=AddSubOp() e2=Term() {e1 = new Ast.Binop(op, e1, e2);})*
   {return e1; }
}

Ast.Exp Term():
{ Ast.Exp e1, e2; Ast.BOP op; }
{
   e1=Factor() ( op=MultDivOp() e2=Factor() {e1 = new Ast.Binop(op, e1, e2);})*
   {return e1; }
}

Ast.Exp Factor():
{
   Ast.Exp f;
   Ast.Exp e;
   List<Ast.Exp> args = new ArrayList<Ast.Exp>();
   boolean hasArgs = false;
   Ast.UOP unop;
   String strLit;
   boolean boolLit;
   int intLit;
}
{
   ( unop=UnOp() f=Factor() { f =  new Ast.Unop(unop, f); }
   | "(" f=Expr() ")"
   /*| f=ExtId() ( ["[" e=Expr() "]" {f = new Ast.ArrayElm(f, e);}]
                 |"(" [args=Args()] ")" {if (f instanceof Ast.Id) {
                        f = new Ast.Call(new Ast.This(), f.nm, args);
                     } else {
                        f = new Ast.Call(f.obj, f.nm, args);
                     }} )
*/
   | strLit=StrLit() { f =  new Ast.StrLit(strLit); }
   | intLit=IntLit() { f =  new Ast.IntLit(intLit); }
   | boolLit=BoolLit() { f =  new Ast.BoolLit(boolLit); })

   {return f;}
}

List<Ast.Exp> Args():
{
   List<Ast.Exp> args = new ArrayList<Ast.Exp>();
   Ast.Exp e;
}
{
   e=Expr() {args.add(e);} ("," e=Expr() {args.add(e);})*
   { return args; }
}

Ast.Exp ExtId():
{
   Ast.Exp extId;
   Ast.Id id;
   boolean self = false;
}
{
   ["this" "." {self=true;}] id=Id() 
   {
      if (self) {
         extId = new Ast.Field(new Ast.This(), id.nm);
      } else {
         extId = id;
      }
   } ("." id=Id() { extId = new Ast.Field(extId, id.nm);})*

   { return extId; }
}

Ast.Type ExtType():
{  Ast.Type type; }
{  
   ("void" { type=null; } | 
   type=Type())
   { return type; }
}

Ast.Type Type():
{  Ast.Type type; 
   Ast.Id typeId; }
{
   (type=BasicType() [ "[" "]" { type=new Ast.ArrayType(type); }] |
   typeId=Id() { type=new Ast.ObjType(typeId.nm); })
   {return type;}
}

Ast.Type BasicType():
{  Ast.Type type; }
{  "boolean" {return new Ast.BoolType(); } | 
   "int" { return new Ast.IntType(); }
}

Ast.Id Id():
{  Token token; }
{
   token=<Id> { return new Ast.Id(token.image); }
}

String StrLit():
{ Token tkn; }
{
  tkn=<StrLit> { return tkn.image; }
}

int IntLit():
{ Token tkn; }
{
  tkn=<IntLit> { return Integer.parseInt(tkn.image); }
}

boolean BoolLit():
{ Token tkn; }
{
  tkn=<BoolLit> { return Boolean.parseBoolean(tkn.image); }
}


Ast.BOP RelOp(): {}
{
 ( "==" { return Ast.BOP.EQ; }
 | "!=" { return Ast.BOP.NE; }
 | "<=" { return Ast.BOP.LE; }
 | ">=" { return Ast.BOP.GE; }
 | "<"  { return Ast.BOP.LT; }
 | ">"  { return Ast.BOP.GT; })
}

Ast.BOP AddSubOp(): {}
{
   ( "+" { return Ast.BOP.ADD; }
   | "-" { return Ast.BOP.SUB; } )
}

Ast.BOP MultDivOp(): {}
{
   ( "*" { return Ast.BOP.MUL; }
   | "/" { return Ast.BOP.DIV; } )
}

Ast.UOP UnOp(): {}
{
   ( "-" { return Ast.UOP.NEG; }
   | "!" { return Ast.UOP.NOT; })
}

